<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Car Movement Tracker</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f0f0f0;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 20px;
      }

      .controls {
        background: white;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .controls button {
        background: #4caf50;
        color: white;
        border: none;
        padding: 10px 20px;
        margin: 5px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }

      .controls button:hover {
        background: #45a049;
      }

      .controls button:disabled {
        background: #cccccc;
        cursor: not-allowed;
      }

      .location-inputs {
        margin-bottom: 15px;
        padding: 10px;
        background: #f9f9f9;
        border-radius: 4px;
        border: 1px solid #ddd;
      }

      .input-group {
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .input-group:last-child {
        margin-bottom: 0;
      }

      .input-group label {
        font-weight: bold;
        min-width: 100px;
        color: #333;
      }

      .input-group input {
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 14px;
        width: 120px;
      }

      .input-group input:focus {
        outline: none;
        border-color: #4caf50;
        box-shadow: 0 0 5px rgba(76, 175, 80, 0.3);
      }

      #map {
        height: 600px;
        width: 100%;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .info-panel {
        background: white;
        padding: 15px;
        border-radius: 8px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .status {
        margin: 10px 0;
        padding: 10px;
        border-radius: 4px;
      }

      .status.loading {
        background: #e3f2fd;
        color: #1976d2;
      }

      .status.error {
        background: #ffebee;
        color: #c62828;
      }

      .status.success {
        background: #e8f5e8;
        color: #2e7d32;
      }

      .data-controls {
        margin-bottom: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .data-controls button {
        background: #2196f3;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }

      .data-controls button:hover {
        background: #1976d2;
      }

      .data-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
      }

      .data-table th,
      .data-table td {
        border: 1px solid #ddd;
        padding: 6px 8px;
        text-align: left;
      }

      .data-table th {
        background-color: #f5f5f5;
        font-weight: bold;
      }

      .data-table tr:nth-child(even) {
        background-color: #f9f9f9;
      }

      .data-table tr:hover {
        background-color: #e3f2fd;
      }

      .status-panel {
        background: white;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .status-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
        margin-top: 10px;
      }

      .service-status {
        padding: 10px;
        border-radius: 4px;
        border: 1px solid #ddd;
      }

      .service-status h4 {
        margin: 0 0 8px 0;
        font-size: 14px;
        color: #333;
      }

      .status-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 8px;
      }

      .status-indicator.online {
        background-color: #4caf50;
      }

      .status-indicator.offline {
        background-color: #f44336;
      }

      .status-indicator.warning {
        background-color: #ff9800;
      }

      .status-indicator.error {
        background-color: #f44336;
      }

      .status-indicator.checking {
        background-color: #2196f3;
        animation: pulse 1.5s infinite;
      }

      @keyframes pulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
        100% {
          opacity: 1;
        }
      }

      .status-details {
        font-size: 12px;
        color: #666;
        margin-top: 5px;
      }

      .refresh-status-btn {
        background: #2196f3;
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        margin-top: 10px;
      }

      .refresh-status-btn:hover {
        background: #1976d2;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Car Movement Tracker</h1>

      <div class="status-panel">
        <h3>Service Status</h3>
        <div class="status-grid">
          <div class="service-status" id="osrmStatus">
            <h4>
              <span class="status-indicator checking" id="osrmIndicator"></span>
              OSRM Engine
            </h4>
            <div style="margin-bottom: 8px">
              <input
                type="text"
                id="osrmUrlInput"
                value="http://localhost:5001"
                style="
                  width: 100%;
                  padding: 4px;
                  border: 1px solid #ddd;
                  border-radius: 3px;
                  font-size: 12px;
                "
                placeholder="OSRM Server URL"
              />
            </div>
            <div id="osrmMessage">Checking status...</div>
            <div class="status-details" id="osrmDetails"></div>
          </div>
          <div class="service-status" id="influxdbStatus">
            <h4>
              <span
                class="status-indicator checking"
                id="influxdbIndicator"
              ></span>
              InfluxDB
            </h4>
            <div style="margin-bottom: 8px">
              <label for="influxdbUrlInput" style="display: block; font-size: 11px; color: #666; margin-bottom: 2px;">URL:</label>
              <input
                type="text"
                id="influxdbUrlInput"
                value="http://localhost:8086"
                style="
                  width: 100%;
                  padding: 4px;
                  border: 1px solid #ddd;
                  border-radius: 3px;
                  font-size: 12px;
                  margin-bottom: 4px;
                "
                placeholder="InfluxDB Server URL"
              />
              <label for="influxdbTokenInput" style="display: block; font-size: 11px; color: #666; margin-bottom: 2px;">Token:</label>
              <input
                type="password"
                id="influxdbTokenInput"
                value=""
                style="
                  width: 100%;
                  padding: 4px;
                  border: 1px solid #ddd;
                  border-radius: 3px;
                  font-size: 12px;
                  margin-bottom: 4px;
                "
                placeholder="InfluxDB Token"
              />
              <div style="display: flex; gap: 4%;">
                <div style="width: 48%;">
                  <label for="influxdbOrgInput" style="display: block; font-size: 11px; color: #666; margin-bottom: 2px;">Organization:</label>
                  <input
                    type="text"
                    id="influxdbOrgInput"
                    value="ciel"
                    style="
                      width: 100%;
                      padding: 4px;
                      border: 1px solid #ddd;
                      border-radius: 3px;
                      font-size: 12px;
                    "
                    placeholder="Organization"
                  />
                </div>
                <div style="width: 48%;">
                  <label for="influxdbBucketInput" style="display: block; font-size: 11px; color: #666; margin-bottom: 2px;">Bucket:</label>
                  <input
                    type="text"
                    id="influxdbBucketInput"
                    value="location_202506"
                    style="
                      width: 100%;
                      padding: 4px;
                      border: 1px solid #ddd;
                      border-radius: 3px;
                      font-size: 12px;
                    "
                    placeholder="Bucket"
                  />
                </div>
              </div>
            </div>
            <div id="influxdbMessage">Checking status...</div>
            <div class="status-details" id="influxdbDetails"></div>
          </div>
        </div>
        <button onclick="refreshServiceStatus()" class="refresh-status-btn">
          Refresh Status
        </button>
      </div>

      <div class="controls">
        <div class="location-inputs">
          <div class="input-group">
            <label for="startLat">Start Location:</label>
            <input
              type="number"
              id="startLat"
              placeholder="Latitude"
              value="35.84"
              step="any"
            />
            <input
              type="number"
              id="startLon"
              placeholder="Longitude"
              value="128.48"
              step="any"
            />
          </div>
          <div class="input-group">
            <label for="destLat">Destination:</label>
            <input
              type="number"
              id="destLat"
              placeholder="Latitude"
              value="35.8519"
              step="any"
            />
            <input
              type="number"
              id="destLon"
              placeholder="Longitude"
              value="128.6727"
              step="any"
            />
          </div>
          <div class="input-group">
            <label for="cyclicalMode">Movement Mode:</label>
            <input
              type="radio"
              id="oneWay"
              name="movementMode"
              value="one-way"
              checked
            />
            <label for="oneWay" style="min-width: auto; margin-right: 15px"
              >One-way</label
            >
            <input
              type="radio"
              id="roundTrip"
              name="movementMode"
              value="round-trip"
            />
            <label for="roundTrip" style="min-width: auto"
              >Round-trip (Cyclical)</label
            >
          </div>
        </div>
        <button onclick="startStreaming()" id="streamBtn" disabled>
          Start Streaming Data
        </button>
        <button onclick="stopStreaming()" id="stopStreamBtn" disabled>
          Stop Streaming
        </button>
        <button onclick="showRoute()" id="routeBtn">Show Route</button>
        <button onclick="getNewRoute()" id="newRouteBtn" disabled>Get New Route</button>
        <button onclick="testRouteUpdate()" id="testRouteBtn" disabled>Test Route Update</button>
        <button onclick="testUpdateRouteAPI()" id="testUpdateAPIBtn" disabled>Test Update Route API</button>
        <button onclick="clearMap()">Clear Map</button>
      </div>

      <div id="status" class="status"></div>

      <div id="map"></div>

      <div class="info-panel">
        <h3>Car Information</h3>
        <div id="carInfo">
          <p>
            <strong>Current Position:</strong>
            <span id="currentPos">Not available</span>
          </p>
          <p>
            <strong>Speed:</strong> <span id="currentSpeed">Not available</span>
          </p>
          <p>
            <strong>Heading:</strong>
            <span id="currentHeading">Not available</span>
          </p>
          <p><strong>Total Points:</strong> <span id="totalPoints">0</span></p>
          <p>
            <strong>Total Distance:</strong>
            <span id="totalDistance">0 km</span>
          </p>
        </div>
      </div>

      <div class="info-panel" id="dataPanel" style="display: none">
        <h3>Loaded Car Data</h3>
        <div class="data-controls">
          <button onclick="toggleDataView()" id="toggleDataBtn">
            Show All Data
          </button>
          <span id="dataCount"></span>
        </div>
        <div
          id="carDataDisplay"
          style="max-height: 400px; overflow-y: auto; margin-top: 10px"
        >
          <!-- Data will be populated here -->
        </div>
      </div>

      <div class="info-panel">
        <h3>API Information</h3>
        <div style="font-size: 14px; line-height: 1.6;">
          <h4 style="margin: 15px 0 10px 0; color: #333;">Available Endpoints:</h4>
          
          <div style="margin-bottom: 15px; padding: 10px; background: #f9f9f9; border-radius: 4px;">
            <strong>GET /api/car-data</strong>
            <p style="margin: 5px 0; color: #666;">Fetch historical car data from InfluxDB (last 500 points)</p>
          </div>

          <div style="margin-bottom: 15px; padding: 10px; background: #f9f9f9; border-radius: 4px;">
            <strong>GET /api/route</strong>
            <p style="margin: 5px 0; color: #666;">Get route geometry from OSRM between two points</p>
            <p style="margin: 5px 0; font-size: 12px; color: #888;">Parameters: origin_lat, origin_lon, dest_lat, dest_lon, osrm_url</p>
            <p style="margin: 5px 0; font-size: 11px; color: #999; font-family: monospace;">Example: /api/route?origin_lat=35.84&origin_lon=128.48&dest_lat=35.8519&dest_lon=128.6727&osrm_url=http://localhost:5001</p>
          </div>

          <div style="margin-bottom: 15px; padding: 10px; background: #f9f9f9; border-radius: 4px;">
            <strong>GET /api/waypoints</strong>
            <p style="margin: 5px 0; color: #666;">Get predefined waypoints for route planning</p>
          </div>

          <div style="margin-bottom: 15px; padding: 10px; background: #f9f9f9; border-radius: 4px;">
            <strong>GET /api/route-from-current</strong>
            <p style="margin: 5px 0; color: #666;">Calculate new route from current car position through waypoints (applied immediately)</p>
            <p style="margin: 5px 0; font-size: 12px; color: #888;">Parameters: osrm_url</p>
            <p style="margin: 5px 0; font-size: 11px; color: #999; font-family: monospace;">Example: /api/route-from-current?osrm_url=http://localhost:5001</p>
          </div>

          <div style="margin-bottom: 15px; padding: 10px; background: #f9f9f9; border-radius: 4px;">
            <strong>POST /api/update-route</strong>
            <p style="margin: 5px 0; color: #666;">Update car's route with new waypoints while streaming (applied immediately)</p>
            <p style="margin: 5px 0; font-size: 12px; color: #888;">Body: {waypoints: [...], osrm_url: "..."}</p>
            <div style="margin: 5px 0; font-size: 11px; color: #999; font-family: monospace; background: #f0f0f0; padding: 8px; border-radius: 3px;">
              Example JSON:<br>
              {<br>
              &nbsp;&nbsp;"waypoints": [<br>
              &nbsp;&nbsp;&nbsp;&nbsp;{"lat": 35.8450, "lng": 128.5200, "name": "Checkpoint 1"},<br>
              &nbsp;&nbsp;&nbsp;&nbsp;{"lat": 35.8500, "lng": 128.5800, "name": "Checkpoint 2"}<br>
              &nbsp;&nbsp;],<br>
              &nbsp;&nbsp;"osrm_url": "http://localhost:5001"<br>
              }
            </div>
          </div>

          <div style="margin-bottom: 15px; padding: 10px; background: #f9f9f9; border-radius: 4px;">
            <strong>GET /api/status/osrm</strong>
            <p style="margin: 5px 0; color: #666;">Check OSRM server status and connectivity</p>
            <p style="margin: 5px 0; font-size: 12px; color: #888;">Parameters: osrm_url</p>
            <p style="margin: 5px 0; font-size: 11px; color: #999; font-family: monospace;">Example: /api/status/osrm?osrm_url=http://localhost:5001</p>
          </div>

          <div style="margin-bottom: 15px; padding: 10px; background: #f9f9f9; border-radius: 4px;">
            <strong>GET /api/status/influxdb</strong>
            <p style="margin: 5px 0; color: #666;">Check InfluxDB server status and configuration</p>
            <p style="margin: 5px 0; font-size: 12px; color: #888;">Parameters: influxdb_url, influxdb_token, influxdb_org, influxdb_bucket</p>
            <p style="margin: 5px 0; font-size: 11px; color: #999; font-family: monospace;">Example: /api/status/influxdb?influxdb_url=http://localhost:8086&influxdb_org=myorg&influxdb_bucket=car_tracking</p>
          </div>

          <div style="margin-bottom: 15px; padding: 10px; background: #f9f9f9; border-radius: 4px;">
            <strong>POST /api/start-generation</strong>
            <p style="margin: 5px 0; color: #666;">Start car data generation with specified route</p>
            <p style="margin: 5px 0; font-size: 12px; color: #888;">Body: {origin_lat, origin_lon, dest_lat, dest_lon, duration, osrm_url, movement_mode}</p>
            <div style="margin: 5px 0; font-size: 11px; color: #999; font-family: monospace; background: #f0f0f0; padding: 8px; border-radius: 3px;">
              Example JSON:<br>
              {<br>
              &nbsp;&nbsp;"origin_lat": 35.84,<br>
              &nbsp;&nbsp;"origin_lon": 128.48,<br>
              &nbsp;&nbsp;"dest_lat": 35.8519,<br>
              &nbsp;&nbsp;"dest_lon": 128.6727,<br>
              &nbsp;&nbsp;"duration": 1,<br>
              &nbsp;&nbsp;"osrm_url": "http://localhost:5001",<br>
              &nbsp;&nbsp;"movement_mode": "one-way"<br>
              }
            </div>
          </div>

          <div style="margin-bottom: 15px; padding: 10px; background: #f9f9f9; border-radius: 4px;">
            <strong>POST /api/stop-generation</strong>
            <p style="margin: 5px 0; color: #666;">Stop the running car data generation process</p>
          </div>

          <div style="margin-bottom: 15px; padding: 10px; background: #f9f9f9; border-radius: 4px;">
            <strong>GET /api/car-data-stream</strong>
            <p style="margin: 5px 0; color: #666;">Real-time streaming of car data using Server-Sent Events (SSE)</p>
            <p style="margin: 5px 0; font-size: 12px; color: #888;">Returns: text/event-stream with JSON car position data</p>
          </div>

          <h4 style="margin: 20px 0 10px 0; color: #333;">Usage Notes:</h4>
          <ul style="margin: 0; padding-left: 20px; color: #666;">
            <li>Use "Show Route" first to plan your path before starting streaming</li>
            <li>During streaming, use "Get New Route" to dynamically change the car's path</li>
            <li>The system supports both one-way and round-trip movement modes</li>
            <li>All coordinates should be in decimal degrees (latitude, longitude)</li>
            <li>OSRM server must be running and accessible for route calculations</li>
            <li>InfluxDB must be configured and accessible for data storage/retrieval</li>
          </ul>
        </div>
      </div>
    </div>

    <script>
      let map;
      let carMarker;
      let pathPolyline;
      let routePolyline;
      let carData = [];
      let showAllData = false;
      let eventSource = null;
      let isStreaming = false;
      let clickMode = "start"; // 'start' or 'destination'
      let startMarker = null;
      let destinationMarker = null;
      let waypointMarkers = [];
      let statusCheckInterval = null;
      let routeCheckInterval = null;
      let lastOSRMStatus = null;
      let lastInfluxDBStatus = null;
      let lastRouteTimestamp = 0;

      function initMap() {
        // Initialize map centered on Los Angeles (matching the data generation area)
        map = new google.maps.Map(document.getElementById("map"), {
          zoom: 13,
          center: { lat: 35.84, lng: 128.48 },
          mapTypeId: "roadmap",
        });

        console.log("🗺️ Google Maps initialized");

        // Initialize polyline for car path (red line showing actual movement)
        pathPolyline = new google.maps.Polyline({
          path: [],
          geodesic: true,
          strokeColor: "#FF0000",
          strokeOpacity: 1.0,
          strokeWeight: 2,
        });
        pathPolyline.setMap(map);

        // Initialize polyline for planned route (blue line showing OSRM route)
        routePolyline = new google.maps.Polyline({
          path: [],
          geodesic: true,
          strokeColor: "#0000FF",
          strokeOpacity: 0.7,
          strokeWeight: 3,
        });
        routePolyline.setMap(map);

        // Add click listener to set start/destination locations
        map.addListener("click", function (event) {
          const lat = event.latLng.lat();
          const lng = event.latLng.lng();

          if (clickMode === "start") {
            setStartLocation(lat, lng);
            clickMode = "destination";
            updateStatus(
              "Start location set. Click on map to set destination.",
              "success",
            );
          } else {
            setDestinationLocation(lat, lng);
            clickMode = "start";
            updateStatus(
              "Destination set. Click on map to set new start location.",
              "success",
            );
          }
        });

        updateStatus(
          "Map initialized. Click on map to set start location, then destination. Show route first to enable streaming.",
          "success",
        );

        // Check service status on page load
        checkServiceStatus();

        // Load InfluxDB settings from environment on page load
        loadInfluxDBSettings();

        // Start automatic status checking every 10 seconds
        startAutoStatusCheck();
      }

      function loadInfluxDBSettings() {
        fetch('/api/influxdb-config')
          .then(response => response.json())
          .then(data => {
            if (!data.error) {
              document.getElementById('influxdbUrlInput').value = data.url || 'http://localhost:8086';
              document.getElementById('influxdbOrgInput').value = data.org || 'myorg';
              document.getElementById('influxdbBucketInput').value = data.bucket || 'car_tracking';
              // Note: Token is not loaded from config for security reasons
            }
          })
          .catch(error => {
            console.log('Could not load InfluxDB config from environment:', error);
            // Keep default values in the input fields
          });
      }

      function startAutoStatusCheck() {
        // Clear any existing interval
        if (statusCheckInterval) {
          clearInterval(statusCheckInterval);
        }
        
        // Check status every 10 seconds
        statusCheckInterval = setInterval(() => {
          checkServiceStatus();
        }, 10000);
        
        console.log('Started automatic status checking every 10 seconds');
      }

      function stopAutoStatusCheck() {
        if (statusCheckInterval) {
          clearInterval(statusCheckInterval);
          statusCheckInterval = null;
          console.log('Stopped automatic status checking');
        }
      }

      function updateStatus(message, type = "loading") {
        const statusDiv = document.getElementById("status");
        statusDiv.textContent = message;
        statusDiv.className = `status ${type}`;
      }

      function startStreaming() {
        if (isStreaming) return;

        // Get coordinates from input fields
        const originLat = parseFloat(document.getElementById("startLat").value);
        const originLon = parseFloat(document.getElementById("startLon").value);
        const destLat = parseFloat(document.getElementById("destLat").value);
        const destLon = parseFloat(document.getElementById("destLon").value);

        // Get movement mode
        const movementMode = document.querySelector(
          'input[name="movementMode"]:checked',
        ).value;

        // Validate inputs
        if (
          isNaN(originLat) ||
          isNaN(originLon) ||
          isNaN(destLat) ||
          isNaN(destLon)
        ) {
          updateStatus(
            "Please enter valid coordinates for start and destination locations",
            "error",
          );
          return;
        }

        isStreaming = true;
        document.getElementById("streamBtn").disabled = true;
        document.getElementById("stopStreamBtn").disabled = false;
        document.getElementById("routeBtn").disabled = true;
        document.getElementById("newRouteBtn").disabled = false;
        document.getElementById("testRouteBtn").disabled = false;
        document.getElementById("testUpdateAPIBtn").disabled = false;
        
        // Start checking for route updates
        startRouteUpdateCheck();

        updateStatus("Starting data generation and streaming...", "loading");

        // Thoroughly clear all existing data and visual elements
        carData = [];

        // Force clear the path polyline multiple times to ensure it's gone
        pathPolyline.setPath([]);
        pathPolyline.setMap(null);
        pathPolyline.setMap(map);
        pathPolyline.setPath([]);

        // Remove car marker if it exists
        if (carMarker) {
          carMarker.setMap(null);
          carMarker = null;
        }

        // Reset car info display
        document.getElementById("currentPos").textContent = "Not available";
        document.getElementById("currentSpeed").textContent = "Not available";
        document.getElementById("currentHeading").textContent = "Not available";
        document.getElementById("totalPoints").textContent = "0";
        document.getElementById("totalDistance").textContent = "0 km";

        // Hide and reset data panel
        document.getElementById("dataPanel").style.display = "none";
        document.getElementById("carDataDisplay").innerHTML = "";
        document.getElementById("dataCount").textContent = "";

        // First, start the data generation script
        fetch("/api/start-generation", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            origin_lat: originLat,
            origin_lon: originLon,
            dest_lat: destLat,
            dest_lon: destLon,
            duration: 1, // 1 hour of data generation
            osrm_url:
              document.getElementById("osrmUrlInput").value.trim() ||
              "http://localhost:5001",
            movement_mode: movementMode,
          }),
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.error) {
              updateStatus(`Error starting generation: ${data.error}`, "error");
              isStreaming = false;
              document.getElementById("streamBtn").disabled = false;
              document.getElementById("stopStreamBtn").disabled = true;
              return;
            }

            updateStatus(
              "Data generation started. Beginning streaming...",
              "loading",
            );

            // Wait a moment for data generation to start, then begin streaming
            setTimeout(() => {
              startEventStream();
            }, 2000);
          })
          .catch((error) => {
            console.error("Error starting generation:", error);
            updateStatus(
              `Error starting generation: ${error.message}`,
              "error",
            );
            isStreaming = false;
            document.getElementById("streamBtn").disabled = false;
            document.getElementById("stopStreamBtn").disabled = true;
          });
      }

      function startEventStream() {
        // Start EventSource for streaming
        eventSource = new EventSource("/api/car-data-stream");

        eventSource.onmessage = function (event) {
          try {
            const newPoint = JSON.parse(event.data);

            if (newPoint.error) {
              updateStatus(`Streaming error: ${newPoint.error}`, "error");
              return;
            }

            // Add new point to data array
            carData.push(newPoint);

            // Update car marker with latest position
            updateCarMarker(newPoint);
            updateCarInfo(newPoint);

            // Update path
            const path = carData.map((point) => ({
              lat: point.latitude,
              lng: point.longitude,
            }));
            pathPolyline.setPath(path);

            // Center map on current position (optional - can be disabled for better UX)
            if (carData.length === 1) {
              // Only center on first point
              map.setCenter({
                lat: newPoint.latitude,
                lng: newPoint.longitude,
              });
              map.setZoom(15);
            }

            // Update info panel
            document.getElementById("totalPoints").textContent = carData.length;
            const totalDistance = calculateTotalDistance(carData);
            document.getElementById("totalDistance").textContent =
              `${totalDistance.toFixed(2)} km`;

            // Update data display if panel is visible
            if (document.getElementById("dataPanel").style.display !== "none") {
              displayCarData();
            }

            updateStatus(
              `Streaming... ${carData.length} points received`,
              "success",
            );
          } catch (error) {
            console.error("Error parsing streaming data:", error);
            updateStatus(`Error parsing data: ${error.message}`, "error");
          }
        };

        eventSource.onerror = function (event) {
          console.error("EventSource error:", event);
          updateStatus("Streaming connection error. Retrying...", "error");
        };

        eventSource.onopen = function (event) {
          updateStatus("Streaming connection established", "success");
          // Show the data panel
          document.getElementById("dataPanel").style.display = "block";
        };
      }

      function stopStreaming() {
        if (!isStreaming) return;

        isStreaming = false;
        document.getElementById("streamBtn").disabled = false;
        document.getElementById("stopStreamBtn").disabled = true;
        document.getElementById("routeBtn").disabled = false;
        document.getElementById("newRouteBtn").disabled = true;
        document.getElementById("testRouteBtn").disabled = true;
        document.getElementById("testUpdateAPIBtn").disabled = true;
        
        // Stop checking for route updates
        stopRouteUpdateCheck();

        if (eventSource) {
          eventSource.close();
          eventSource = null;
        }

        // Force clear the path when stopping streaming
        pathPolyline.setPath([]);

        // Stop the data generation process
        fetch("/api/stop-generation", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
        })
          .then((response) => response.json())
          .then((data) => {
            console.log("Stop generation response:", data.message);
            updateStatus(
              `Streaming stopped. Data generation stopped. Total points: ${carData.length}`,
              "success",
            );
          })
          .catch((error) => {
            console.error("Error stopping data generation:", error);
            updateStatus(
              `Streaming stopped. Total points: ${carData.length} (Warning: Could not stop data generation)`,
              "success",
            );
          });
      }

      function updateCarMarker(point) {
        const position = { lat: point.latitude, lng: point.longitude };

        if (!carMarker) {
          // Create new marker
          carMarker = new google.maps.Marker({
            position: position,
            map: map,
            title: `Car Position - Speed: ${point.speed} km/h`,
            icon: {
              path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
              scale: 8,
              fillColor: "#4CAF50",
              fillOpacity: 1,
              strokeColor: "#2E7D32",
              strokeWeight: 2,
              rotation: point.heading || 0,
            },
            zIndex: 1000,
          });

          console.log("Created new car marker at:", position);
        } else {
          // Update existing marker
          carMarker.setPosition(position);

          // Update the icon rotation
          const currentIcon = carMarker.getIcon();
          const newIcon = {
            ...currentIcon,
            rotation: point.heading || 0,
          };
          carMarker.setIcon(newIcon);

          // Update title
          carMarker.setTitle(`Car Position - Speed: ${point.speed} km/h`);

          console.log("Updated car marker to:", position);
        }
      }

      function updateCarInfo(point) {
        document.getElementById("currentPos").textContent =
          `${point.latitude.toFixed(6)}, ${point.longitude.toFixed(6)}`;
        document.getElementById("currentSpeed").textContent =
          `${point.speed} km/h`;
        document.getElementById("currentHeading").textContent =
          `${point.heading}°`;
      }

      function calculateTotalDistance(points) {
        if (points.length < 2) return 0;

        let totalDistance = 0;

        for (let i = 1; i < points.length; i++) {
          const lat1 = points[i - 1].latitude;
          const lon1 = points[i - 1].longitude;
          const lat2 = points[i].latitude;
          const lon2 = points[i].longitude;

          // Haversine formula for distance calculation
          const R = 6371; // Earth's radius in kilometers
          const dLat = ((lat2 - lat1) * Math.PI) / 180;
          const dLon = ((lon2 - lon1) * Math.PI) / 180;
          const a =
            Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos((lat1 * Math.PI) / 180) *
              Math.cos((lat2 * Math.PI) / 180) *
              Math.sin(dLon / 2) *
              Math.sin(dLon / 2);
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          const distance = R * c;

          totalDistance += distance;
        }

        return totalDistance;
      }

      function toggleDataView() {
        showAllData = !showAllData;
        displayCarData();

        const btn = document.getElementById("toggleDataBtn");
        btn.textContent = showAllData ? "Show Recent Data" : "Show All Data";
      }

      function displayCarData() {
        const dataDisplay = document.getElementById("carDataDisplay");
        const dataCount = document.getElementById("dataCount");

        if (carData.length === 0) {
          dataDisplay.innerHTML = "<p>No data available</p>";
          dataCount.textContent = "";
          return;
        }

        // Determine how many records to show (reverse order so recent is at top)
        let dataToShow;
        if (showAllData) {
          dataToShow = [...carData].reverse(); // Show all data, most recent first
        } else {
          dataToShow = carData.slice(-20).reverse(); // Show last 20, most recent first
        }

        dataCount.textContent = `Showing ${dataToShow.length} of ${carData.length} records`;

        // Create table
        let tableHTML = `
          <table class="data-table">
            <thead>
              <tr>
                <th>Time</th>
                <th>Latitude</th>
                <th>Longitude</th>
                <th>Speed (km/h)</th>
                <th>Heading (°)</th>
              </tr>
            </thead>
            <tbody>
        `;

        dataToShow.forEach((point, index) => {
          const time = new Date(point.time).toLocaleString();
          tableHTML += `
            <tr onclick="highlightPoint(${carData.indexOf(point)})" style="cursor: pointer;">
              <td>${time}</td>
              <td>${point.latitude.toFixed(6)}</td>
              <td>${point.longitude.toFixed(6)}</td>
              <td>${point.speed}</td>
              <td>${point.heading}</td>
            </tr>
          `;
        });

        tableHTML += `
            </tbody>
          </table>
        `;

        dataDisplay.innerHTML = tableHTML;
      }

      function highlightPoint(index) {
        if (index >= 0 && index < carData.length) {
          const point = carData[index];
          updateCarMarker(point);
          updateCarInfo(point);

          // Center map on selected point
          map.setCenter({
            lat: point.latitude,
            lng: point.longitude,
          });

          // Zoom in a bit
          if (map.getZoom() < 15) {
            map.setZoom(15);
          }
        }
      }

      function clearMap() {
        // Stop streaming first
        stopStreaming();

        if (carMarker) {
          carMarker.setMap(null);
          carMarker = null;
        }

        // Clear start and destination markers
        if (startMarker) {
          startMarker.setMap(null);
          startMarker = null;
        }
        if (destinationMarker) {
          destinationMarker.setMap(null);
          destinationMarker = null;
        }

        // Clear waypoint markers
        clearWaypointMarkers();

        pathPolyline.setPath([]);
        routePolyline.setPath([]);
        carData = [];

        document.getElementById("currentPos").textContent = "Not available";
        document.getElementById("currentSpeed").textContent = "Not available";
        document.getElementById("currentHeading").textContent = "Not available";
        document.getElementById("totalPoints").textContent = "0";
        document.getElementById("totalDistance").textContent = "0 km";

        // Hide data panel
        document.getElementById("dataPanel").style.display = "none";
        showAllData = false;
        document.getElementById("toggleDataBtn").textContent = "Show All Data";

        updateStatus("Map cleared.", "success");
      }

      function setStartLocation(lat, lng) {
        // Update input fields
        document.getElementById("startLat").value = lat.toFixed(6);
        document.getElementById("startLon").value = lng.toFixed(6);

        // Remove existing start marker
        if (startMarker) {
          startMarker.setMap(null);
        }

        // Create new start marker (green)
        startMarker = new google.maps.Marker({
          position: { lat: lat, lng: lng },
          map: map,
          title: "Start Location",
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 8,
            fillColor: "#4CAF50",
            fillOpacity: 1,
            strokeColor: "#2E7D32",
            strokeWeight: 2,
          },
          zIndex: 999,
        });
      }

      function setDestinationLocation(lat, lng) {
        // Update input fields
        document.getElementById("destLat").value = lat.toFixed(6);
        document.getElementById("destLon").value = lng.toFixed(6);

        // Remove existing destination marker
        if (destinationMarker) {
          destinationMarker.setMap(null);
        }

        // Create new destination marker (red)
        destinationMarker = new google.maps.Marker({
          position: { lat: lat, lng: lng },
          map: map,
          title: "Destination",
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 8,
            fillColor: "#F44336",
            fillOpacity: 1,
            strokeColor: "#C62828",
            strokeWeight: 2,
          },
          zIndex: 999,
        });
      }

      function showRoute() {
        // Clear any existing path data before showing new route
        carData = [];
        pathPolyline.setPath([]);

        // Remove car marker if it exists
        if (carMarker) {
          carMarker.setMap(null);
          carMarker = null;
        }

        // Get coordinates from input fields
        const originLat = parseFloat(document.getElementById("startLat").value);
        const originLon = parseFloat(document.getElementById("startLon").value);
        const destLat = parseFloat(document.getElementById("destLat").value);
        const destLon = parseFloat(document.getElementById("destLon").value);
        const osrmUrl =
          document.getElementById("osrmUrlInput").value.trim() ||
          "http://localhost:5001";

        // Validate inputs
        if (
          isNaN(originLat) ||
          isNaN(originLon) ||
          isNaN(destLat) ||
          isNaN(destLon)
        ) {
          updateStatus(
            "Please enter valid coordinates for start and destination locations",
            "error",
          );
          return;
        }

        console.log("Fetching route with coordinates:", {
          originLat,
          originLon,
          destLat,
          destLon,
        });

        updateStatus("Fetching route from OSRM...", "loading");

        fetch(
          `/api/route?origin_lat=${originLat}&origin_lon=${originLon}&dest_lat=${destLat}&dest_lon=${destLon}&osrm_url=${osrmUrl}`,
        )
          .then((response) => {
            console.log("Route API response status:", response.status);
            return response.json();
          })
          .then((data) => {
            console.log("Route API response data:", data);

            if (data.error) {
              updateStatus(`Route error: ${data.error}`, "error");
              console.error("Route API error:", data.error);
              return;
            }

            // Convert route points to Google Maps format
            const routePath = data.route_points.map((point) => ({
              lat: point[0],
              lng: point[1],
            }));

            console.log(
              "Route path points:",
              routePath.length,
              "first few:",
              routePath.slice(0, 3),
            );

            // Display the route on the map
            routePolyline.setPath(routePath);
            console.log("Route polyline path set");

            // Fit the map to show the entire route
            const bounds = new google.maps.LatLngBounds();
            routePath.forEach((point) => bounds.extend(point));
            map.fitBounds(bounds);

            updateStatus(
              `Route loaded: ${(data.distance / 1000).toFixed(2)}km, ${(data.duration / 60).toFixed(1)}min`,
              "success",
            );

            // Enable the streaming button after route is loaded
            document.getElementById("streamBtn").disabled = false;
          })
          .catch((error) => {
            console.error("Error fetching route:", error);
            updateStatus(`Error fetching route: ${error.message}`, "error");
          });
      }

      function getNewRoute() {
        if (!isStreaming) {
          updateStatus("Cannot get new route - streaming is not active", "error");
          return;
        }

        updateStatus("Getting new route from current position...", "loading");

        const osrmUrl =
          document.getElementById("osrmUrlInput").value.trim() ||
          "http://localhost:5001";

        fetch(`/api/route-from-current?osrm_url=${osrmUrl}`)
          .then((response) => response.json())
          .then((data) => {
            if (data.error) {
              updateStatus(`New route error: ${data.error}`, "error");
              return;
            }

            // Clear old waypoint markers
            clearWaypointMarkers();

            // Convert route points to Google Maps format
            const routePath = data.route_points.map((point) => ({
              lat: point[0],
              lng: point[1],
            }));

            // Update the route polyline with new route (change color to indicate it's a new route)
            routePolyline.setPath(routePath);
            routePolyline.setOptions({
              strokeColor: "#FF6600", // Orange color for new route
              strokeOpacity: 0.8,
              strokeWeight: 4,
            });

            // Add waypoint markers
            data.waypoints.forEach((waypoint, index) => {
              const marker = new google.maps.Marker({
                position: { lat: waypoint.lat, lng: waypoint.lng },
                map: map,
                title: waypoint.name,
                icon: {
                  path: google.maps.SymbolPath.CIRCLE,
                  scale: 8,
                  fillColor: "#FF6600",
                  fillOpacity: 1,
                  strokeColor: "#CC4400",
                  strokeWeight: 2,
                },
                zIndex: 998,
              });
              waypointMarkers.push(marker);
            });

            // Fit map to show the new route
            if (routePath.length > 0) {
              const bounds = new google.maps.LatLngBounds();
              routePath.forEach((point) => bounds.extend(point));
              map.fitBounds(bounds);
            }

            updateStatus(
              `New route activated: ${(data.distance / 1000).toFixed(2)}km, ${(data.duration / 60).toFixed(1)}min. Car is now following this path!`,
              "success",
            );

            console.log("New route loaded with waypoints:", data.waypoints);
          })
          .catch((error) => {
            console.error("Error getting new route:", error);
            updateStatus(`Error getting new route: ${error.message}`, "error");
          });
      }

      function clearWaypointMarkers() {
        waypointMarkers.forEach(marker => {
          marker.setMap(null);
        });
        waypointMarkers = [];
      }

      function checkServiceStatus() {
        checkOSRMStatus();
        checkInfluxDBStatus();
      }

      function checkOSRMStatus() {
        const indicator = document.getElementById("osrmIndicator");
        const message = document.getElementById("osrmMessage");
        const details = document.getElementById("osrmDetails");

        const osrmUrl =
          document.getElementById("osrmUrlInput").value.trim() ||
          "http://localhost:5001";
        
        fetch(`/api/status/osrm?osrm_url=${encodeURIComponent(osrmUrl)}`)
          .then((response) => response.json())
          .then((data) => {
            // Create a status signature to compare with previous status
            const statusSignature = JSON.stringify({
              status: data.status,
              message: data.message,
              url: data.url,
              response_time: data.response_time_ms ? Math.round(data.response_time_ms / 100) * 100 : null // Round to nearest 100ms to avoid constant updates
            });

            // Only update UI if status has changed
            if (lastOSRMStatus !== statusSignature) {
              indicator.className = `status-indicator ${data.status}`;
              message.textContent = data.message;

              let detailsText = `URL: ${data.url}`;
              if (data.response_time_ms) {
                detailsText += ` | Response: ${data.response_time_ms.toFixed(0)}ms`;
              }
              details.textContent = detailsText;

              lastOSRMStatus = statusSignature;
            }
          })
          .catch((error) => {
            const errorSignature = JSON.stringify({
              status: 'error',
              message: 'Failed to check OSRM status',
              error: error.message
            });

            if (lastOSRMStatus !== errorSignature) {
              indicator.className = "status-indicator error";
              message.textContent = "Failed to check OSRM status";
              details.textContent = `Error: ${error.message}`;
              lastOSRMStatus = errorSignature;
            }
          });
      }

      function checkInfluxDBStatus() {
        const indicator = document.getElementById("influxdbIndicator");
        const message = document.getElementById("influxdbMessage");
        const details = document.getElementById("influxdbDetails");

        const influxdbUrl =
          document.getElementById("influxdbUrlInput").value.trim() ||
          "http://localhost:8086";
        const influxdbToken =
          document.getElementById("influxdbTokenInput").value.trim();
        const influxdbOrg =
          document.getElementById("influxdbOrgInput").value.trim() || "myorg";
        const influxdbBucket =
          document.getElementById("influxdbBucketInput").value.trim() ||
          "car_tracking";

        const params = new URLSearchParams({
          influxdb_url: influxdbUrl,
          influxdb_org: influxdbOrg,
          influxdb_bucket: influxdbBucket,
        });

        // Add token to params if provided
        if (influxdbToken) {
          params.append('influxdb_token', influxdbToken);
        }

        fetch(`/api/status/influxdb?${params}`)
          .then((response) => response.json())
          .then((data) => {
            // Create a status signature to compare with previous status
            const statusSignature = JSON.stringify({
              status: data.status,
              message: data.message,
              url: data.url,
              org: data.org,
              bucket: data.bucket,
              response_time: data.response_time_ms ? Math.round(data.response_time_ms / 100) * 100 : null // Round to nearest 100ms
            });

            // Only update UI if status has changed
            if (lastInfluxDBStatus !== statusSignature) {
              indicator.className = `status-indicator ${data.status}`;
              message.textContent = data.message;

              let detailsText = `URL: ${data.url}`;
              if (data.org) {
                detailsText += ` | Org: ${data.org}`;
              }
              if (data.bucket) {
                detailsText += ` | Bucket: ${data.bucket}`;
              }
              if (data.response_time_ms) {
                detailsText += ` | Response: ${data.response_time_ms.toFixed(0)}ms`;
              }
              details.textContent = detailsText;

              lastInfluxDBStatus = statusSignature;
            }
          })
          .catch((error) => {
            const errorSignature = JSON.stringify({
              status: 'error',
              message: 'Failed to check InfluxDB status',
              error: error.message
            });

            if (lastInfluxDBStatus !== errorSignature) {
              indicator.className = "status-indicator error";
              message.textContent = "Failed to check InfluxDB status";
              details.textContent = `Error: ${error.message}`;
              lastInfluxDBStatus = errorSignature;
            }
          })
      }

      function refreshServiceStatus() {
        checkServiceStatus();
      }

      function updateRouteWithWaypoints(waypoints) {
        if (!isStreaming) {
          updateStatus("Cannot update route - streaming is not active", "error");
          return;
        }

        updateStatus("Updating route with new waypoints...", "loading");

        const osrmUrl =
          document.getElementById("osrmUrlInput").value.trim() ||
          "http://localhost:5001";

        fetch('/api/update-route', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            waypoints: waypoints,
            osrm_url: osrmUrl
          })
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.error) {
              updateStatus(`Route update error: ${data.error}`, "error");
              return;
            }

            // Clear old waypoint markers
            clearWaypointMarkers();

            // Convert route points to Google Maps format
            const routePath = data.route_points.map((point) => ({
              lat: point[0],
              lng: point[1],
            }));

            // Update the route polyline with new route (change color to indicate it's an updated route)
            routePolyline.setPath(routePath);
            routePolyline.setOptions({
              strokeColor: "#9C27B0", // Purple color for updated route
              strokeOpacity: 0.8,
              strokeWeight: 4,
            });

            // Add waypoint markers
            data.waypoints.forEach((waypoint, index) => {
              const marker = new google.maps.Marker({
                position: { lat: waypoint.lat, lng: waypoint.lng },
                map: map,
                title: waypoint.name || `Waypoint ${index + 1}`,
                icon: {
                  path: google.maps.SymbolPath.CIRCLE,
                  scale: 8,
                  fillColor: "#9C27B0",
                  fillOpacity: 1,
                  strokeColor: "#7B1FA2",
                  strokeWeight: 2,
                },
                zIndex: 998,
              });
              waypointMarkers.push(marker);
            });

            // Fit map to show the updated route
            if (routePath.length > 0) {
              const bounds = new google.maps.LatLngBounds();
              routePath.forEach((point) => bounds.extend(point));
              map.fitBounds(bounds);
            }

            updateStatus(
              `Route updated: ${(data.distance / 1000).toFixed(2)}km, ${(data.duration / 60).toFixed(1)}min. Car is now following the new path!`,
              "success",
            );

            console.log("Route updated with waypoints:", data.waypoints);
          })
          .catch((error) => {
            console.error("Error updating route:", error);
            updateStatus(`Error updating route: ${error.message}`, "error");
          });
      }

      function testRouteUpdate() {
        if (!isStreaming) {
          updateStatus("Cannot test route update - streaming is not active", "error");
          return;
        }

        updateStatus("Testing route update...", "loading");

        fetch('/api/test-route-update', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          }
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.error) {
              updateStatus(`Test route update error: ${data.error}`, "error");
              return;
            }

            if (data.success && data.route_points && data.route_points.length > 0) {
              // Clear old waypoint markers
              clearWaypointMarkers();

              // Convert route points to Google Maps format
              const routePath = data.route_points.map((point) => ({
                lat: point[0],
                lng: point[1],
              }));

              // Update the route polyline with new route (change color to indicate it's a test route)
              routePolyline.setPath(routePath);
              routePolyline.setOptions({
                strokeColor: "#E91E63", // Pink color for test route
                strokeOpacity: 0.8,
                strokeWeight: 4,
              });

              // Add waypoint markers
              data.waypoints.forEach((waypoint, index) => {
                const marker = new google.maps.Marker({
                  position: { lat: waypoint.lat, lng: waypoint.lng },
                  map: map,
                  title: waypoint.name || `Test Waypoint ${index + 1}`,
                  icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    scale: 8,
                    fillColor: "#E91E63",
                    fillOpacity: 1,
                    strokeColor: "#C2185B",
                    strokeWeight: 2,
                  },
                  zIndex: 998,
                });
                waypointMarkers.push(marker);
              });

              // Fit map to show the test route
              if (routePath.length > 0) {
                const bounds = new google.maps.LatLngBounds();
                routePath.forEach((point) => bounds.extend(point));
                map.fitBounds(bounds);
              }

              updateStatus(
                `Test route applied: ${(data.distance / 1000).toFixed(2)}km, ${(data.duration / 60).toFixed(1)}min. Car is now following the test path!`,
                "success",
              );

              console.log("Test route applied with waypoints:", data.waypoints);
            } else {
              updateStatus(`Test route update failed: ${data.message}`, "error");
            }
          })
          .catch((error) => {
            console.error("Error testing route update:", error);
            updateStatus(`Error testing route update: ${error.message}`, "error");
          });
      }

      function testUpdateRouteAPI() {
        if (!isStreaming) {
          updateStatus("Cannot test update route API - streaming is not active", "error");
          return;
        }

        updateStatus("Testing update route API...", "loading");

        // Test waypoints - different from the test-route-update endpoint
        const testWaypoints = [
          {"lat": 35.838193, "lng": 128.742013, "name": "API Test Checkpoint 1"},
          {"lat": 35.835442, "lng": 128.348375, "name": "API Test Checkpoint 2"}
        ];

        const osrmUrl = document.getElementById("osrmUrlInput").value.trim() || "http://localhost:5001";

        console.log("🔄 Sending update route API request with waypoints:", testWaypoints);

        fetch('/api/update-route', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            waypoints: testWaypoints,
            osrm_url: osrmUrl
          })
        })
          .then((response) => {
            console.log("🔄 Update route API response status:", response.status);
            return response.json();
          })
          .then((data) => {
            console.log("🔄 Update route API response data:", data);
            
            if (data.error) {
              updateStatus(`Update route API error: ${data.error}`, "error");
              return;
            }

            // Check if we have route data to display
            if (data.route_points && data.route_points.length > 0) {
              console.log("🔄 Displaying updated route with", data.route_points.length, "points");
              
              // Clear old waypoint markers
              clearWaypointMarkers();

              // Convert route points to Google Maps format
              const routePath = data.route_points.map((point) => ({
                lat: point[0],
                lng: point[1],
              }));

              console.log("🔄 Route path first few points:", routePath.slice(0, 5));

              // Update the route polyline with new route (change color to indicate it's an API test route)
              routePolyline.setPath(routePath);
              routePolyline.setOptions({
                strokeColor: "#FF5722", // Deep orange color for API test route
                strokeOpacity: 0.8,
                strokeWeight: 4,
              });

              console.log("🔄 Route polyline updated with", routePath.length, "points");

              // Add waypoint markers
              if (data.waypoints && data.waypoints.length > 0) {
                data.waypoints.forEach((waypoint, index) => {
                  const marker = new google.maps.Marker({
                    position: { lat: waypoint.lat, lng: waypoint.lng },
                    map: map,
                    title: waypoint.name || `API Test Waypoint ${index + 1}`,
                    icon: {
                      path: google.maps.SymbolPath.CIRCLE,
                      scale: 8,
                      fillColor: "#FF5722",
                      fillOpacity: 1,
                      strokeColor: "#D84315",
                      strokeWeight: 2,
                    },
                    zIndex: 998,
                  });
                  waypointMarkers.push(marker);
                  console.log("🔄 Added waypoint marker:", waypoint.name, "at", waypoint.lat, waypoint.lng);
                });
              }

              // Fit map to show the API test route
              if (routePath.length > 0) {
                const bounds = new google.maps.LatLngBounds();
                routePath.forEach((point) => bounds.extend(point));
                map.fitBounds(bounds);
                console.log("🔄 Map bounds fitted to show route");
              }

              updateStatus(
                `Update route API successful: ${(data.distance / 1000).toFixed(2)}km, ${(data.duration / 60).toFixed(1)}min. Car is now following the updated path!`,
                "success",
              );

              console.log("✅ Update route API test completed successfully");
            } else {
              console.log("❌ No route points in response:", data);
              updateStatus(`Update route API failed: No route data received`, "error");
            }
          })
          .catch((error) => {
            console.error("❌ Error testing update route API:", error);
            updateStatus(`Error testing update route API: ${error.message}`, "error");
          });
      }

      // Generic function to update route with custom waypoints (can be called from console)
      function updateRouteWithCustomWaypoints(waypoints) {
        if (!isStreaming) {
          console.error("Cannot update route - streaming is not active");
          updateStatus("Cannot update route - streaming is not active", "error");
          return Promise.reject("Streaming not active");
        }

        console.log("🔄 Updating route with custom waypoints:", waypoints);
        updateStatus("Updating route with custom waypoints...", "loading");

        const osrmUrl = document.getElementById("osrmUrlInput").value.trim() || "http://localhost:5001";

        return fetch('/api/update-route', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            waypoints: waypoints,
            osrm_url: osrmUrl
          })
        })
          .then((response) => {
            console.log("🔄 Custom route update response status:", response.status);
            return response.json();
          })
          .then((data) => {
            console.log("🔄 Custom route update response data:", data);
            
            if (data.error) {
              updateStatus(`Route update error: ${data.error}`, "error");
              throw new Error(data.error);
            }

            // Check if we have route data to display
            if (data.route_points && data.route_points.length > 0) {
              console.log("🔄 Displaying custom updated route with", data.route_points.length, "points");
              
              // Clear old waypoint markers
              clearWaypointMarkers();

              // Convert route points to Google Maps format
              const routePath = data.route_points.map((point) => ({
                lat: point[0],
                lng: point[1],
              }));

              // Update the route polyline with new route (use purple for custom routes)
              routePolyline.setPath(routePath);
              routePolyline.setOptions({
                strokeColor: "#9C27B0", // Purple color for custom route
                strokeOpacity: 0.8,
                strokeWeight: 4,
              });

              // Add waypoint markers
              if (data.waypoints && data.waypoints.length > 0) {
                data.waypoints.forEach((waypoint, index) => {
                  const marker = new google.maps.Marker({
                    position: { lat: waypoint.lat, lng: waypoint.lng },
                    map: map,
                    title: waypoint.name || `Custom Waypoint ${index + 1}`,
                    icon: {
                      path: google.maps.SymbolPath.CIRCLE,
                      scale: 8,
                      fillColor: "#9C27B0",
                      fillOpacity: 1,
                      strokeColor: "#7B1FA2",
                      strokeWeight: 2,
                    },
                    zIndex: 998,
                  });
                  waypointMarkers.push(marker);
                });
              }

              // Fit map to show the custom route
              if (routePath.length > 0) {
                const bounds = new google.maps.LatLngBounds();
                routePath.forEach((point) => bounds.extend(point));
                map.fitBounds(bounds);
              }

              updateStatus(
                `Custom route updated: ${(data.distance / 1000).toFixed(2)}km, ${(data.duration / 60).toFixed(1)}min. Car is now following the custom path!`,
                "success",
              );

              console.log("✅ Custom route update completed successfully");
              return data;
            } else {
              console.log("❌ No route points in custom route response:", data);
              updateStatus(`Custom route update failed: No route data received`, "error");
              throw new Error("No route data received");
            }
          })
          .catch((error) => {
            console.error("❌ Error updating custom route:", error);
            updateStatus(`Error updating custom route: ${error.message}`, "error");
            throw error;
          });
      }

      // Make the function globally available for console access
      window.updateRouteWithCustomWaypoints = updateRouteWithCustomWaypoints;

      function startRouteUpdateCheck() {
        // Clear any existing interval
        if (routeCheckInterval) {
          clearInterval(routeCheckInterval);
        }
        
        // Check for route updates every 5 seconds during streaming
        routeCheckInterval = setInterval(() => {
          checkForRouteUpdates();
        }, 5000);
        
        console.log('Started automatic route update checking every 5 seconds');
      }

      function stopRouteUpdateCheck() {
        if (routeCheckInterval) {
          clearInterval(routeCheckInterval);
          routeCheckInterval = null;
          console.log('Stopped automatic route update checking');
        }
      }

      function checkForRouteUpdates() {
        if (!isStreaming) {
          return; // Only check during streaming
        }

        // Get current route data to check if it has been updated
        fetch('/api/route-status')
          .then(response => response.json())
          .then(data => {
            if (data.error) {
              console.log('Route status check error:', data.error);
              return;
            }

            // Check if route has been updated since last check
            if (data.route_updated && data.update_timestamp > lastRouteTimestamp) {
              console.log('🔄 Route update detected via polling! Updating map...');
              lastRouteTimestamp = data.update_timestamp;
              
              // Update the map with the new route
              updateMapWithNewRoute(data);
            }
          })
          .catch(error => {
            console.log('Route status check failed:', error);
          });
      }

      function updateMapWithNewRoute(routeData) {
        if (!routeData.route_points || routeData.route_points.length === 0) {
          console.log('No route points to display');
          return;
        }

        console.log('🗺️ Updating map with new route:', routeData.route_points.length, 'points');

        // Clear old waypoint markers
        clearWaypointMarkers();

        // Convert route points to Google Maps format
        const routePath = routeData.route_points.map((point) => ({
          lat: point[0],
          lng: point[1],
        }));

        // Update the route polyline with new route (use teal color for auto-detected updates)
        routePolyline.setPath(routePath);
        routePolyline.setOptions({
          strokeColor: "#009688", // Teal color for auto-detected route updates
          strokeOpacity: 0.8,
          strokeWeight: 4,
        });

        // Add waypoint markers if available
        if (routeData.waypoints && routeData.waypoints.length > 0) {
          routeData.waypoints.forEach((waypoint, index) => {
            const marker = new google.maps.Marker({
              position: { lat: waypoint.lat, lng: waypoint.lng },
              map: map,
              title: waypoint.name || `Auto Waypoint ${index + 1}`,
              icon: {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 8,
                fillColor: "#009688",
                fillOpacity: 1,
                strokeColor: "#00695C",
                strokeWeight: 2,
              },
              zIndex: 998,
            });
            waypointMarkers.push(marker);
          });
        }

        // Fit map to show the updated route
        if (routePath.length > 0) {
          const bounds = new google.maps.LatLngBounds();
          routePath.forEach((point) => bounds.extend(point));
          map.fitBounds(bounds);
        }

        updateStatus(
          `Route auto-updated: ${(routeData.distance / 1000).toFixed(2)}km, ${(routeData.duration / 60).toFixed(1)}min. Map updated automatically!`,
          "success",
        );

        console.log("✅ Map updated with auto-detected route change");
      }

      // Stop auto-checking when page is about to unload
      window.addEventListener('beforeunload', function() {
        stopAutoStatusCheck();
        stopRouteUpdateCheck();
      });
    </script>

    <!-- Google Maps API loaded from environment variable -->
    <script
      async
      defer
      src="https://maps.googleapis.com/maps/api/js?key={{ google_maps_api_key }}&callback=initMap"
    ></script>
  </body>
</html>
