<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Car Movement Tracker</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f0f0f0;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 20px;
      }

      .controls {
        background: white;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .controls button {
        background: #4caf50;
        color: white;
        border: none;
        padding: 10px 20px;
        margin: 5px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }

      .controls button:hover {
        background: #45a049;
      }

      .controls button:disabled {
        background: #cccccc;
        cursor: not-allowed;
      }

      .location-inputs {
        margin-bottom: 15px;
        padding: 10px;
        background: #f9f9f9;
        border-radius: 4px;
        border: 1px solid #ddd;
      }

      .input-group {
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .input-group:last-child {
        margin-bottom: 0;
      }

      .input-group label {
        font-weight: bold;
        min-width: 100px;
        color: #333;
      }

      .input-group input {
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 14px;
        width: 120px;
      }

      .input-group input:focus {
        outline: none;
        border-color: #4caf50;
        box-shadow: 0 0 5px rgba(76, 175, 80, 0.3);
      }

      #map {
        height: 600px;
        width: 100%;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .info-panel {
        background: white;
        padding: 15px;
        border-radius: 8px;
        margin-top: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .status {
        margin: 10px 0;
        padding: 10px;
        border-radius: 4px;
      }

      .status.loading {
        background: #e3f2fd;
        color: #1976d2;
      }

      .status.error {
        background: #ffebee;
        color: #c62828;
      }

      .status.success {
        background: #e8f5e8;
        color: #2e7d32;
      }

      .data-controls {
        margin-bottom: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .data-controls button {
        background: #2196f3;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }

      .data-controls button:hover {
        background: #1976d2;
      }

      .data-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
      }

      .data-table th,
      .data-table td {
        border: 1px solid #ddd;
        padding: 6px 8px;
        text-align: left;
      }

      .data-table th {
        background-color: #f5f5f5;
        font-weight: bold;
      }

      .data-table tr:nth-child(even) {
        background-color: #f9f9f9;
      }

      .data-table tr:hover {
        background-color: #e3f2fd;
      }

      .status-panel {
        background: white;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .status-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
        margin-top: 10px;
      }

      .service-status {
        padding: 10px;
        border-radius: 4px;
        border: 1px solid #ddd;
      }

      .service-status h4 {
        margin: 0 0 8px 0;
        font-size: 14px;
        color: #333;
      }

      .status-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 8px;
      }

      .status-indicator.online {
        background-color: #4caf50;
      }

      .status-indicator.offline {
        background-color: #f44336;
      }

      .status-indicator.warning {
        background-color: #ff9800;
      }

      .status-indicator.error {
        background-color: #f44336;
      }

      .status-indicator.checking {
        background-color: #2196f3;
        animation: pulse 1.5s infinite;
      }

      @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
      }

      .status-details {
        font-size: 12px;
        color: #666;
        margin-top: 5px;
      }

      .refresh-status-btn {
        background: #2196f3;
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        margin-top: 10px;
      }

      .refresh-status-btn:hover {
        background: #1976d2;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Car Movement Tracker</h1>

      <div class="status-panel">
        <h3>Service Status</h3>
        <div class="status-grid">
          <div class="service-status" id="osrmStatus">
            <h4>
              <span class="status-indicator checking" id="osrmIndicator"></span>
              OSRM Engine
            </h4>
            <div id="osrmMessage">Checking status...</div>
            <div class="status-details" id="osrmDetails"></div>
          </div>
          <div class="service-status" id="influxdbStatus">
            <h4>
              <span class="status-indicator checking" id="influxdbIndicator"></span>
              InfluxDB
            </h4>
            <div id="influxdbMessage">Checking status...</div>
            <div class="status-details" id="influxdbDetails"></div>
          </div>
        </div>
        <button onclick="refreshServiceStatus()" class="refresh-status-btn">
          Refresh Status
        </button>
      </div>

      <div class="controls">
        <div class="location-inputs">
          <div class="input-group">
            <label for="startLat">Start Location:</label>
            <input
              type="number"
              id="startLat"
              placeholder="Latitude"
              value="35.84"
              step="any"
            />
            <input
              type="number"
              id="startLon"
              placeholder="Longitude"
              value="128.48"
              step="any"
            />
          </div>
          <div class="input-group">
            <label for="destLat">Destination:</label>
            <input
              type="number"
              id="destLat"
              placeholder="Latitude"
              value="35.8519"
              step="any"
            />
            <input
              type="number"
              id="destLon"
              placeholder="Longitude"
              value="128.6727"
              step="any"
            />
          </div>
          <div class="input-group">
            <label for="cyclicalMode">Movement Mode:</label>
            <input type="radio" id="oneWay" name="movementMode" value="one-way" checked>
            <label for="oneWay" style="min-width: auto; margin-right: 15px;">One-way</label>
            <input type="radio" id="roundTrip" name="movementMode" value="round-trip">
            <label for="roundTrip" style="min-width: auto;">Round-trip (Cyclical)</label>
          </div>
        </div>
        <button onclick="startStreaming()" id="streamBtn" disabled>
          Start Streaming Data
        </button>
        <button onclick="stopStreaming()" id="stopStreamBtn" disabled>
          Stop Streaming
        </button>
        <button onclick="showRoute()" id="routeBtn">Show Route</button>
        <button onclick="clearMap()">Clear Map</button>
      </div>

      <div id="status" class="status"></div>

      <div id="map"></div>

      <div class="info-panel">
        <h3>Car Information</h3>
        <div id="carInfo">
          <p>
            <strong>Current Position:</strong>
            <span id="currentPos">Not available</span>
          </p>
          <p>
            <strong>Speed:</strong> <span id="currentSpeed">Not available</span>
          </p>
          <p>
            <strong>Heading:</strong>
            <span id="currentHeading">Not available</span>
          </p>
          <p><strong>Total Points:</strong> <span id="totalPoints">0</span></p>
          <p>
            <strong>Total Distance:</strong>
            <span id="totalDistance">0 km</span>
          </p>
        </div>
      </div>

      <div class="info-panel" id="dataPanel" style="display: none">
        <h3>Loaded Car Data</h3>
        <div class="data-controls">
          <button onclick="toggleDataView()" id="toggleDataBtn">
            Show All Data
          </button>
          <span id="dataCount"></span>
        </div>
        <div
          id="carDataDisplay"
          style="max-height: 400px; overflow-y: auto; margin-top: 10px"
        >
          <!-- Data will be populated here -->
        </div>
      </div>
    </div>

    <script>
      let map;
      let carMarker;
      let pathPolyline;
      let routePolyline;
      let carData = [];
      let showAllData = false;
      let eventSource = null;
      let isStreaming = false;
      let clickMode = "start"; // 'start' or 'destination'
      let startMarker = null;
      let destinationMarker = null;

      function initMap() {
        // Initialize map centered on Los Angeles (matching the data generation area)
        map = new google.maps.Map(document.getElementById("map"), {
          zoom: 13,
          center: { lat: 35.84, lng: 128.48 },
          mapTypeId: "roadmap",
        });

        // Initialize polyline for car path (red line showing actual movement)
        pathPolyline = new google.maps.Polyline({
          path: [],
          geodesic: true,
          strokeColor: "#FF0000",
          strokeOpacity: 1.0,
          strokeWeight: 2,
        });
        pathPolyline.setMap(map);

        // Initialize polyline for planned route (blue line showing OSRM route)
        routePolyline = new google.maps.Polyline({
          path: [],
          geodesic: true,
          strokeColor: "#0000FF",
          strokeOpacity: 0.7,
          strokeWeight: 3,
        });
        routePolyline.setMap(map);

        // Add click listener to set start/destination locations
        map.addListener("click", function (event) {
          const lat = event.latLng.lat();
          const lng = event.latLng.lng();

          if (clickMode === "start") {
            setStartLocation(lat, lng);
            clickMode = "destination";
            updateStatus(
              "Start location set. Click on map to set destination.",
              "success",
            );
          } else {
            setDestinationLocation(lat, lng);
            clickMode = "start";
            updateStatus(
              "Destination set. Click on map to set new start location.",
              "success",
            );
          }
        });

        updateStatus(
          "Map initialized. Click on map to set start location, then destination. Show route first to enable streaming.",
          "success",
        );

        // Check service status on page load
        checkServiceStatus();
      }

      function updateStatus(message, type = "loading") {
        const statusDiv = document.getElementById("status");
        statusDiv.textContent = message;
        statusDiv.className = `status ${type}`;
      }

      function startStreaming() {
        if (isStreaming) return;

        // Get coordinates from input fields
        const originLat = parseFloat(document.getElementById("startLat").value);
        const originLon = parseFloat(document.getElementById("startLon").value);
        const destLat = parseFloat(document.getElementById("destLat").value);
        const destLon = parseFloat(document.getElementById("destLon").value);
        
        // Get movement mode
        const movementMode = document.querySelector('input[name="movementMode"]:checked').value;

        // Validate inputs
        if (
          isNaN(originLat) ||
          isNaN(originLon) ||
          isNaN(destLat) ||
          isNaN(destLon)
        ) {
          updateStatus(
            "Please enter valid coordinates for start and destination locations",
            "error",
          );
          return;
        }

        isStreaming = true;
        document.getElementById("streamBtn").disabled = true;
        document.getElementById("stopStreamBtn").disabled = false;

        updateStatus("Starting data generation and streaming...", "loading");

        // Thoroughly clear all existing data and visual elements
        carData = [];
        
        // Force clear the path polyline multiple times to ensure it's gone
        pathPolyline.setPath([]);
        pathPolyline.setMap(null);
        pathPolyline.setMap(map);
        pathPolyline.setPath([]);
        
        // Remove car marker if it exists
        if (carMarker) {
          carMarker.setMap(null);
          carMarker = null;
        }
        
        // Reset car info display
        document.getElementById("currentPos").textContent = "Not available";
        document.getElementById("currentSpeed").textContent = "Not available";
        document.getElementById("currentHeading").textContent = "Not available";
        document.getElementById("totalPoints").textContent = "0";
        document.getElementById("totalDistance").textContent = "0 km";
        
        // Hide and reset data panel
        document.getElementById("dataPanel").style.display = "none";
        document.getElementById("carDataDisplay").innerHTML = "";
        document.getElementById("dataCount").textContent = "";

        // First, start the data generation script
        fetch("/api/start-generation", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            origin_lat: originLat,
            origin_lon: originLon,
            dest_lat: destLat,
            dest_lon: destLon,
            duration: 1, // 1 hour of data generation
            osrm_url: "http://localhost:5001",
            movement_mode: movementMode,
          }),
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.error) {
              updateStatus(`Error starting generation: ${data.error}`, "error");
              isStreaming = false;
              document.getElementById("streamBtn").disabled = false;
              document.getElementById("stopStreamBtn").disabled = true;
              return;
            }

            updateStatus(
              "Data generation started. Beginning streaming...",
              "loading",
            );

            // Wait a moment for data generation to start, then begin streaming
            setTimeout(() => {
              startEventStream();
            }, 2000);
          })
          .catch((error) => {
            console.error("Error starting generation:", error);
            updateStatus(
              `Error starting generation: ${error.message}`,
              "error",
            );
            isStreaming = false;
            document.getElementById("streamBtn").disabled = false;
            document.getElementById("stopStreamBtn").disabled = true;
          });
      }

      function startEventStream() {
        // Start EventSource for streaming
        eventSource = new EventSource("/api/car-data-stream");

        eventSource.onmessage = function (event) {
          try {
            const newPoint = JSON.parse(event.data);

            if (newPoint.error) {
              updateStatus(`Streaming error: ${newPoint.error}`, "error");
              return;
            }

            // Add new point to data array
            carData.push(newPoint);

            // Update car marker with latest position
            updateCarMarker(newPoint);
            updateCarInfo(newPoint);

            // Update path
            const path = carData.map((point) => ({
              lat: point.latitude,
              lng: point.longitude,
            }));
            pathPolyline.setPath(path);

            // Center map on current position (optional - can be disabled for better UX)
            if (carData.length === 1) {
              // Only center on first point
              map.setCenter({
                lat: newPoint.latitude,
                lng: newPoint.longitude,
              });
              map.setZoom(15);
            }

            // Update info panel
            document.getElementById("totalPoints").textContent = carData.length;
            const totalDistance = calculateTotalDistance(carData);
            document.getElementById("totalDistance").textContent =
              `${totalDistance.toFixed(2)} km`;

            // Update data display if panel is visible
            if (document.getElementById("dataPanel").style.display !== "none") {
              displayCarData();
            }

            updateStatus(
              `Streaming... ${carData.length} points received`,
              "success",
            );
          } catch (error) {
            console.error("Error parsing streaming data:", error);
            updateStatus(`Error parsing data: ${error.message}`, "error");
          }
        };

        eventSource.onerror = function (event) {
          console.error("EventSource error:", event);
          updateStatus("Streaming connection error. Retrying...", "error");
        };

        eventSource.onopen = function (event) {
          updateStatus("Streaming connection established", "success");
          // Show the data panel
          document.getElementById("dataPanel").style.display = "block";
        };
      }

      function stopStreaming() {
        if (!isStreaming) return;

        isStreaming = false;
        document.getElementById("streamBtn").disabled = false;
        document.getElementById("stopStreamBtn").disabled = true;

        if (eventSource) {
          eventSource.close();
          eventSource = null;
        }

        // Force clear the path when stopping streaming
        pathPolyline.setPath([]);

        // Stop the data generation process
        fetch("/api/stop-generation", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
        })
          .then((response) => response.json())
          .then((data) => {
            console.log("Stop generation response:", data.message);
            updateStatus(
              `Streaming stopped. Data generation stopped. Total points: ${carData.length}`,
              "success",
            );
          })
          .catch((error) => {
            console.error("Error stopping data generation:", error);
            updateStatus(
              `Streaming stopped. Total points: ${carData.length} (Warning: Could not stop data generation)`,
              "success",
            );
          });
      }

      function updateCarMarker(point) {
        const position = { lat: point.latitude, lng: point.longitude };

        if (!carMarker) {
          // Create new marker
          carMarker = new google.maps.Marker({
            position: position,
            map: map,
            title: `Car Position - Speed: ${point.speed} km/h`,
            icon: {
              path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
              scale: 8,
              fillColor: "#4CAF50",
              fillOpacity: 1,
              strokeColor: "#2E7D32",
              strokeWeight: 2,
              rotation: point.heading || 0,
            },
            zIndex: 1000,
          });

          console.log("Created new car marker at:", position);
        } else {
          // Update existing marker
          carMarker.setPosition(position);

          // Update the icon rotation
          const currentIcon = carMarker.getIcon();
          const newIcon = {
            ...currentIcon,
            rotation: point.heading || 0,
          };
          carMarker.setIcon(newIcon);

          // Update title
          carMarker.setTitle(`Car Position - Speed: ${point.speed} km/h`);

          console.log("Updated car marker to:", position);
        }
      }

      function updateCarInfo(point) {
        document.getElementById("currentPos").textContent =
          `${point.latitude.toFixed(6)}, ${point.longitude.toFixed(6)}`;
        document.getElementById("currentSpeed").textContent =
          `${point.speed} km/h`;
        document.getElementById("currentHeading").textContent =
          `${point.heading}°`;
      }

      function calculateTotalDistance(points) {
        if (points.length < 2) return 0;

        let totalDistance = 0;

        for (let i = 1; i < points.length; i++) {
          const lat1 = points[i - 1].latitude;
          const lon1 = points[i - 1].longitude;
          const lat2 = points[i].latitude;
          const lon2 = points[i].longitude;

          // Haversine formula for distance calculation
          const R = 6371; // Earth's radius in kilometers
          const dLat = ((lat2 - lat1) * Math.PI) / 180;
          const dLon = ((lon2 - lon1) * Math.PI) / 180;
          const a =
            Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos((lat1 * Math.PI) / 180) *
              Math.cos((lat2 * Math.PI) / 180) *
              Math.sin(dLon / 2) *
              Math.sin(dLon / 2);
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          const distance = R * c;

          totalDistance += distance;
        }

        return totalDistance;
      }

      function toggleDataView() {
        showAllData = !showAllData;
        displayCarData();

        const btn = document.getElementById("toggleDataBtn");
        btn.textContent = showAllData ? "Show Recent Data" : "Show All Data";
      }

      function displayCarData() {
        const dataDisplay = document.getElementById("carDataDisplay");
        const dataCount = document.getElementById("dataCount");

        if (carData.length === 0) {
          dataDisplay.innerHTML = "<p>No data available</p>";
          dataCount.textContent = "";
          return;
        }

        // Determine how many records to show (reverse order so recent is at top)
        let dataToShow;
        if (showAllData) {
          dataToShow = [...carData].reverse(); // Show all data, most recent first
        } else {
          dataToShow = carData.slice(-20).reverse(); // Show last 20, most recent first
        }

        dataCount.textContent = `Showing ${dataToShow.length} of ${carData.length} records`;

        // Create table
        let tableHTML = `
          <table class="data-table">
            <thead>
              <tr>
                <th>Time</th>
                <th>Latitude</th>
                <th>Longitude</th>
                <th>Speed (km/h)</th>
                <th>Heading (°)</th>
              </tr>
            </thead>
            <tbody>
        `;

        dataToShow.forEach((point, index) => {
          const time = new Date(point.time).toLocaleString();
          tableHTML += `
            <tr onclick="highlightPoint(${carData.indexOf(point)})" style="cursor: pointer;">
              <td>${time}</td>
              <td>${point.latitude.toFixed(6)}</td>
              <td>${point.longitude.toFixed(6)}</td>
              <td>${point.speed}</td>
              <td>${point.heading}</td>
            </tr>
          `;
        });

        tableHTML += `
            </tbody>
          </table>
        `;

        dataDisplay.innerHTML = tableHTML;
      }

      function highlightPoint(index) {
        if (index >= 0 && index < carData.length) {
          const point = carData[index];
          updateCarMarker(point);
          updateCarInfo(point);

          // Center map on selected point
          map.setCenter({
            lat: point.latitude,
            lng: point.longitude,
          });

          // Zoom in a bit
          if (map.getZoom() < 15) {
            map.setZoom(15);
          }
        }
      }

      function clearMap() {
        // Stop streaming first
        stopStreaming();

        if (carMarker) {
          carMarker.setMap(null);
          carMarker = null;
        }

        // Clear start and destination markers
        if (startMarker) {
          startMarker.setMap(null);
          startMarker = null;
        }
        if (destinationMarker) {
          destinationMarker.setMap(null);
          destinationMarker = null;
        }

        pathPolyline.setPath([]);
        routePolyline.setPath([]);
        carData = [];

        document.getElementById("currentPos").textContent = "Not available";
        document.getElementById("currentSpeed").textContent = "Not available";
        document.getElementById("currentHeading").textContent = "Not available";
        document.getElementById("totalPoints").textContent = "0";
        document.getElementById("totalDistance").textContent = "0 km";

        // Hide data panel
        document.getElementById("dataPanel").style.display = "none";
        showAllData = false;
        document.getElementById("toggleDataBtn").textContent = "Show All Data";

        updateStatus("Map cleared.", "success");
      }

      function setStartLocation(lat, lng) {
        // Update input fields
        document.getElementById("startLat").value = lat.toFixed(6);
        document.getElementById("startLon").value = lng.toFixed(6);

        // Remove existing start marker
        if (startMarker) {
          startMarker.setMap(null);
        }

        // Create new start marker (green)
        startMarker = new google.maps.Marker({
          position: { lat: lat, lng: lng },
          map: map,
          title: "Start Location",
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 8,
            fillColor: "#4CAF50",
            fillOpacity: 1,
            strokeColor: "#2E7D32",
            strokeWeight: 2,
          },
          zIndex: 999,
        });
      }

      function setDestinationLocation(lat, lng) {
        // Update input fields
        document.getElementById("destLat").value = lat.toFixed(6);
        document.getElementById("destLon").value = lng.toFixed(6);

        // Remove existing destination marker
        if (destinationMarker) {
          destinationMarker.setMap(null);
        }

        // Create new destination marker (red)
        destinationMarker = new google.maps.Marker({
          position: { lat: lat, lng: lng },
          map: map,
          title: "Destination",
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 8,
            fillColor: "#F44336",
            fillOpacity: 1,
            strokeColor: "#C62828",
            strokeWeight: 2,
          },
          zIndex: 999,
        });
      }

      function showRoute() {
        // Clear any existing path data before showing new route
        carData = [];
        pathPolyline.setPath([]);
        
        // Remove car marker if it exists
        if (carMarker) {
          carMarker.setMap(null);
          carMarker = null;
        }

        // Get coordinates from input fields
        const originLat = parseFloat(document.getElementById("startLat").value);
        const originLon = parseFloat(document.getElementById("startLon").value);
        const destLat = parseFloat(document.getElementById("destLat").value);
        const destLon = parseFloat(document.getElementById("destLon").value);
        const osrmUrl = "http://localhost:5001";

        // Validate inputs
        if (
          isNaN(originLat) ||
          isNaN(originLon) ||
          isNaN(destLat) ||
          isNaN(destLon)
        ) {
          updateStatus(
            "Please enter valid coordinates for start and destination locations",
            "error",
          );
          return;
        }

        console.log("Fetching route with coordinates:", {
          originLat,
          originLon,
          destLat,
          destLon,
        });

        updateStatus("Fetching route from OSRM...", "loading");

        fetch(
          `/api/route?origin_lat=${originLat}&origin_lon=${originLon}&dest_lat=${destLat}&dest_lon=${destLon}&osrm_url=${osrmUrl}`,
        )
          .then((response) => {
            console.log("Route API response status:", response.status);
            return response.json();
          })
          .then((data) => {
            console.log("Route API response data:", data);

            if (data.error) {
              updateStatus(`Route error: ${data.error}`, "error");
              console.error("Route API error:", data.error);
              return;
            }

            // Convert route points to Google Maps format
            const routePath = data.route_points.map((point) => ({
              lat: point[0],
              lng: point[1],
            }));

            console.log(
              "Route path points:",
              routePath.length,
              "first few:",
              routePath.slice(0, 3),
            );

            // Display the route on the map
            routePolyline.setPath(routePath);
            console.log("Route polyline path set");

            // Fit the map to show the entire route
            const bounds = new google.maps.LatLngBounds();
            routePath.forEach((point) => bounds.extend(point));
            map.fitBounds(bounds);

            updateStatus(
              `Route loaded: ${(data.distance / 1000).toFixed(2)}km, ${(data.duration / 60).toFixed(1)}min`,
              "success",
            );

            // Enable the streaming button after route is loaded
            document.getElementById("streamBtn").disabled = false;
          })
          .catch((error) => {
            console.error("Error fetching route:", error);
            updateStatus(`Error fetching route: ${error.message}`, "error");
          });
      }

      function checkServiceStatus() {
        checkOSRMStatus();
        checkInfluxDBStatus();
      }

      function checkOSRMStatus() {
        const indicator = document.getElementById("osrmIndicator");
        const message = document.getElementById("osrmMessage");
        const details = document.getElementById("osrmDetails");

        indicator.className = "status-indicator checking";
        message.textContent = "Checking OSRM status...";
        details.textContent = "";

        const osrmUrl = "http://localhost:5001";
        fetch(`/api/status/osrm?osrm_url=${encodeURIComponent(osrmUrl)}`)
          .then((response) => response.json())
          .then((data) => {
            indicator.className = `status-indicator ${data.status}`;
            message.textContent = data.message;

            let detailsText = `URL: ${data.url}`;
            if (data.response_time_ms) {
              detailsText += ` | Response: ${data.response_time_ms.toFixed(0)}ms`;
            }
            details.textContent = detailsText;
          })
          .catch((error) => {
            indicator.className = "status-indicator error";
            message.textContent = "Failed to check OSRM status";
            details.textContent = `Error: ${error.message}`;
          });
      }

      function checkInfluxDBStatus() {
        const indicator = document.getElementById("influxdbIndicator");
        const message = document.getElementById("influxdbMessage");
        const details = document.getElementById("influxdbDetails");

        indicator.className = "status-indicator checking";
        message.textContent = "Checking InfluxDB status...";
        details.textContent = "";

        fetch("/api/status/influxdb")
          .then((response) => response.json())
          .then((data) => {
            indicator.className = `status-indicator ${data.status}`;
            message.textContent = data.message;

            let detailsText = `URL: ${data.url}`;
            if (data.org) {
              detailsText += ` | Org: ${data.org}`;
            }
            if (data.bucket) {
              detailsText += ` | Bucket: ${data.bucket}`;
            }
            if (data.response_time_ms) {
              detailsText += ` | Response: ${data.response_time_ms.toFixed(0)}ms`;
            }
            details.textContent = detailsText;
          })
          .catch((error) => {
            indicator.className = "status-indicator error";
            message.textContent = "Failed to check InfluxDB status";
            details.textContent = `Error: ${error.message}`;
          });
      }

      function refreshServiceStatus() {
        checkServiceStatus();
      }
    </script>

    <!-- Google Maps API loaded from environment variable -->
    <script
      async
      defer
      src="https://maps.googleapis.com/maps/api/js?key={{ google_maps_api_key }}&callback=initMap"
    ></script>
  </body>
</html>
